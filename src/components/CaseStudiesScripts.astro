<script data-astro-rerun>
  document.addEventListener("astro:page-load", () => {
  // Register once (safe if called multiple times)

  // Clean any prior run
  window.ctx?.revert();
  window.ctx = null;

  // Detect scroller and set defaults (explicitly fall back to window)
  const scroller = document.querySelector("#wrapper") || null;
  ScrollTrigger.defaults({ scroller: scroller || window });
  window.ctx = gsap.context(() => {
            window.Smoother = ScrollSmoother.create({
        wrapper: '#wrapper',
        content: '#content'
        });
    // ---- Camera ticker (unchanged, but store on window for cleanup) ----
    window.SpaceManager.whenReady().then(() => {
      const camera = window.SpaceManager.getCamera();
      const camProxy = { x: -20, y: -30, z: 80, ox: 0, oy: 0 };
      const qCamX = gsap.quickTo(camera.position, "x", { duration: 0.22, ease: "power3.out" });
      const qCamY = gsap.quickTo(camera.position, "y", { duration: 0.22, ease: "power3.out" });
      const qCamZ = gsap.quickTo(camera.position, "z", { duration: 0.32, ease: "power3.out" });
      const updateCamera = () => {
        qCamX(camProxy.x + camProxy.ox);
        qCamY(camProxy.y + camProxy.oy);
        qCamZ(camProxy.z);
        camera.updateMatrixWorld();
      };
      window.__tickerFn && gsap.ticker.remove(window.__tickerFn);
      window.__tickerFn = updateCamera;
      gsap.ticker.add(updateCamera);
    });

    // ---- Sections, dots, buttons ----
    const sections = Array.from(document.querySelectorAll("section"));
    const clamp = (n, min, max) => Math.max(min, Math.min(max, n));
    const prevBtn = document.querySelector(".previous-section");
    const nextBtn = document.querySelector(".next-section");

    const navMap = new Map(); // id -> dot element
    sections.forEach((sec) => {
      const dot = document.querySelector(`[data-nav-item="${sec.id}"]`);
      if (dot) navMap.set(sec.id, dot);
    });

    let currentIndex = 0;

    const setActiveDot = (idx) => {
      sections.forEach((sec, i) => {
        const dot = navMap.get(sec.id);
        if (!dot) return;
        const active = i === idx;
        dot.classList.toggle("dot_active", active);
        dot.setAttribute("aria-current", active ? "true" : "false");
        dot.setAttribute("aria-selected", active ? "true" : "false");
      });
    };

    const updateButtons = (idx) => {
      const atStart = idx <= 0;
      const atEnd = idx >= sections.length - 1;
      if (prevBtn) {
        prevBtn.toggleAttribute("disabled", atStart);
        prevBtn.setAttribute("aria-disabled", String(atStart));
        prevBtn.classList.toggle("is-disabled", atStart);
      }
      if (nextBtn) {
        nextBtn.toggleAttribute("disabled", atEnd);
        nextBtn.setAttribute("aria-disabled", String(atEnd));
        nextBtn.classList.toggle("is-disabled", atEnd);
      }
    };

    const setActiveIndex = (idx) => {
      idx = clamp(idx, 0, sections.length - 1);
      if (idx === currentIndex) return;
      currentIndex = idx;
      setActiveDot(idx);
      updateButtons(idx);
    };

    const scrollToIndex = (idx) => {
      idx = clamp(idx, 0, sections.length - 1);
      const target = sections[idx];
      if (!target) return;

        gsap.to(window.Smoother, {
            scrollTop: window.Smoother.offset(target, "top top"),
             duration: 0.8,
            ease: "power2.out",
            onComplete: () => setActiveIndex(idx),
        });
    };

    // Buttons
    if (prevBtn) {
      prevBtn.addEventListener("click", (e) => { e.preventDefault(); scrollToIndex(currentIndex - 1); });
      prevBtn.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") { e.preventDefault(); scrollToIndex(currentIndex - 1); }
      });
    }
    if (nextBtn) {
      nextBtn.addEventListener("click", (e) => { e.preventDefault(); scrollToIndex(currentIndex + 1); });
      nextBtn.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") { e.preventDefault(); scrollToIndex(currentIndex + 1); }
      });
    }

    // Dots
    navMap.forEach((dotEl, id) => {
      if (!dotEl.hasAttribute("role")) dotEl.setAttribute("role", "button");
      if (!dotEl.hasAttribute("tabindex")) dotEl.setAttribute("tabindex", "0");
      dotEl.setAttribute("aria-controls", id);
      const go = () => {
        const idx = sections.findIndex((s) => s.id === id);
        if (idx !== -1) scrollToIndex(idx);
      };
      dotEl.addEventListener("click", (e) => { e.preventDefault(); go(); });
      dotEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") { e.preventDefault(); go(); }
      });
    });

    // ---- Per-section watchers (replaces global onUpdate + getNearestIndex) ----
    const sectionTriggers = sections.map((sec, i) =>
      ScrollTrigger.create({
        trigger: sec,
        start: "top center",
        end: "bottom center",
        // keep section 'active' while its center is inside the viewport
        onEnter: () => setActiveIndex(i),
        onEnterBack: () => setActiveIndex(i),
        anticipatePin: 1,
      })
    );

    // ---- Horizontal galleries (pinned) ----
    const galleries = gsap.utils.toArray("section.horizontal");
    galleries.forEach((sec, i) => {
      const pinWrap  = sec.querySelector(".pin-wrap");
      const animWrap = pinWrap?.querySelector(".animation-wrap");
      if (!pinWrap || !animWrap) return;

      pinWrap.style.overflowX = "hidden";

      const distance = () => {
        const vw = scroller ? scroller.clientWidth : window.innerWidth;
        return Math.max(0, animWrap.scrollWidth - vw);
      };

        gsap.fromTo(
        animWrap,
        { x: () => (animWrap.classList.contains("to-right") ? 0 : -distance()) },
        {
            x: () => (animWrap.classList.contains("to-right") ? -distance() : 0),
            ease: "none",
            scrollTrigger: {
            id: `horiz-${i}`,
            trigger: sec,
            start: "top top",
            end: () => "+=" + distance(),
            pin: pinWrap,
            scrub: true,
            invalidateOnRefresh: true,
            pinType: scroller ? "transform" : "fixed",
            anticipatePin: 1,
            refreshPriority: 1,
            // snap: {
            //     snapTo: (val) => val,     // or a function/array of progress positions
            //     duration: { min: 0.2, max: 0.6 },
            //     ease: "power1.inOut",
            //     inertia: false,           // <-- valid HERE
            //     directional: true,
            //     delay: 0.02
            // },
            // markers: true,
            onRefresh: () => {
                // ensure touch-axis lock even if added dynamically
                sec.style.touchAction = "pan-x";
                pinWrap.style.touchAction = "pan-x";
            }
            }
        }
        );
    });

    // ---- Initialize UI state after everything is measured ----
    requestAnimationFrame(() => {
      ScrollTrigger.refresh();
      const activeIdx = sectionTriggers.findIndex((t) => t.isActive);
      setActiveIndex(activeIdx !== -1 ? activeIdx : 0);
    });

    // expose (optional)
    window.scrollToSectionIndex = scrollToIndex;
  });
}, { once: false });

// Cleanup on Astro view transition
document.addEventListener("astro:before-swap", () => {
  
  try {
    if (window.ctx) { window.ctx.revert(); window.ctx = null; }
    window.ScrollTrigger?.killAll();
      window.__tickerFn && gsap.ticker.remove(window.__tickerFn);

  } catch (e) {
  } finally {
    if (window.__tickerFn && window.gsap) {
      gsap.ticker.remove(window.__tickerFn);
      window.__tickerFn = null;
    }
  }
});
</script>
